# MeetUp_Official
Educational project 

## Необходиые библиотеки
1. nlohmann/json (команда установки для Manjaro: sudo pacman -S nlohmann-json)
2. gtest (команда установки для Manjaro: sudo pacman -S gtest)
3. libpqxx (команда установки для Manjaro: sudo pacman -S libpqxx )
=======
Educational project

<h1><b> Описание работы асинхронного http-сервера </b></h1>

Сервер должен уметь принимать одновременно множество клиентов и обрабатывать запрос каждого в неблокирующем режиме.
В данном блоке используется паттерн Команда для возможности задавать различное поведение через единый интерфейс. Для этого реализованы следующие сущности:
<ul>
    <li>сервер - event loop, ждущий активности на слушающем сокете</li>
    <li>менеджер соединений, хранящий в себе пулл всех имеющихся соединений</li>
    <li>соединение, хранящее тело запроса, требуемый обработчик, буффер для асихронного считывания и ответ</li>
    <li>обработчик - посредник для вызова обрабатывающих функций(в данном случае - парсеров)</li>
    <li>парсер http-запроса, позволяющий обрабатывать запрос по мере его считывания из буффера в асинхронном режиме</li>
    <li>запрос/ответ - структуры, имеющие поля для записи необходымых данных(заголовков, тела и статуса готовности)</li>
</ul>
<h2> Запуск сервера </h2>

1. Сервер реализован на базе интерфейса, включающий методы по запуску, принятию клиентского соединения и останова.
2. Для инициализации работы необходим адрес, порт и путь к рабочей директории. Добавляются сигналы, посредством которых возможно удаленное управление сервером. После этого открывается слушающий сокет. Сервер готов принимать запросы.

<h2> Обработка входящего соединения </h2>

3. За активность при подключении клиента отвечает сущность asio::io_context и asio::ip::tcp::acceptor. После подключения клиента создается std::make_shared&lt;ClientConnection&gt;. Это соединение, вместе с клиентским сокетом через move-семантику передается Менеджеру соединений. Последний, в свою очередь добавляет соединение в std::set&lt;connection_ptr&gt; connections_ и вызывает у соединения метод start(). Теперь обработка этого соединения ведется в асихронном режиме по мере считывания данных из буффера.

<h2> Получения запроса </h2>

4. Метод start() запускает операцию по асинхронному чтению. ... auto self(shared_from_this()). Когда на сокете удается считать опредленное кол-во байт в буффер, через socket_.async_read_some вызывается функция-обработчик этого события, в которую передается кол-во считанных байтов. Далее вызывется парсер, который находится внутри сущности соединения, реализованный по принципу конечного автомата, который обрабатывает каждый символ через свой метод Consume(char input), и возвращает статус готовности (good, bad, indeterminate). В случае, когда парсинг не завершён, ожидание готовности на чтение вызывается повторно.

<h2> Формирование ответа </h2>

5. Когда парсинг запроса завершён, вызывается метод обработки запроса request_handler_.handle_request(request_, reply_). На этом этапе запрос передаётся на другой блок бэкенда, который осуществляет бизнес-логику и возвращает ответ. Однако,для отладки сервера далее реализуется логика по отдаче файлов из рабочей директории, через путь в url, для чего существует служебный метод url_decode(), преобразующий url в путь до файла. Данные из файла считываются и передаются в тело ответа. Здесь же заполняются заголовки ответа.

<h2> Отправка ответа </h2>

6. Если формирование ответа прошло корректно, то ответ готов к отправе. У соединения вызывается метод do_write(), асинхронно пишущий в клиентский сокет ответ. Boost::asio позволяет отправлять данные в виде пакетов, полученных разбиением ответа на множество мелких буфферов через метод reply_.to_buffers(), минимизируя опасность медленных клиентов. Если запись всех данных прошла успешно, то в пулле клиентских соединений вызывается метод о закрытии соединения.

<br>
<i>Термины и определения</i>
<hr>

<ul>
    <li><b>Паттерн Команда</b> - поведенческий шаблон, в котором объект используется для инкапсуляции всей информации, необходимой для выполнения действия или вызова события в более позднее время. Эта информация включает в себя имя метода, объект, который является владельцем метода и значения параметров метода. <br>
    Четыре термина всегда связаны с шаблоном Команда: команды (command), приёмник команд (receiver), вызывающий команды (invoker) и клиент (client). Объект Command знает о приёмнике и вызывает метод приемника. Значения параметров приёмника сохраняются в команде. Вызывающий объект (invoker) знает, как выполнить команду и, возможно, делает учёт и запись выполненных команд. Вызывающий объект (invoker) ничего не знает о конкретной команде, он знает только об интерфейсе. Оба объекта (вызывающий объект и несколько объектов команд) принадлежат объекту клиента (client). Клиент решает, какие команды выполнить и когда. Чтобы выполнить команду он передает объект команды вызывающему объекту (invoker).</li>
    <li><b>std::make_shared</b> - более безопасный способ создать shared_ptr. Поскольку "," не является Sequence point и возможна утечка ресурсов. К тому же позволяет минимизировать использование new</li>
    <li><b>std::shared_from_this()</b> метод, базового класса(std::enable_shared_from_this&lt;my_class&gt;), создающий shared_prt текущего объекта </li>
    <li><b>std::enable_shared_from_this</b> - позволяет внутри объекта создавать shared_prt на себя же. Необходимо наследоваться от этого класса, чтобы иметь возможность вызывать shared_from_this()</li>
    <li><b>[this, self]</b>Здесь auto self(shared_from_this()). Такой захват в лямбду позволяет использовать методы класса ClientConnection, а с помощью self, создавая shared pointer на себя же, мы пролонгируем время жизни объекта, когда потребуется вызвать do_read() и выйти из области видимости</li>
    <li><b>boost::asio::io_context</b> - класс, через который осущетсвляется синхронизация всех многопоточных и асинхронных операций. Метод run() запускает аналог event loop, содержащий очередь задач, которые добавляются после вызово асинхронных операций. run() будет работать, пока ожидающие операции завершаются или пока вы сами не вызовете io_service::stop(). Чтобы сохранить экземпляр io_service работающим добавляется одна или несколько асинхронных операций </li>
     <li><b>boost::asio::resolver.resolve(address, port)</b> </li>
    <li><b>boost::asio::acceptor</b> - сущность в Boost.Asio, позволяющая обрабатывать входящие соединения</li>
    <li><b>boost::asio::async_accept()</b> - асинхронно вызывает обработчик с сигнатурой void (boost::system::error_code ec, boost::asio::ip::tcp::socket socket) при подключении</li>
    <li><b>boost::asio::ip::tcp::endpoint</b>. Конечная точка - это адрес подключения вместе с портом.</li>
    <li><b>boost::asio::socket boost::asio::socke.shutdown()</b> - эта функция отключает операцию send , receive или обе сразу же после вызова</li>
    <li><b>boost::asio::async_connect(endpoint)</b> - эта функция асинхронно подключается по данному адресу.</li>
    <li><b>boost::asio::buffer(some_buffer)</b>. В основном оборачивается любой буфер, который у нас есть в классе, что позволяет функциям из Boost.Asio итерироваться по буферу. Экземпляр some_buffer должен удовлетворять некоторым требованиям, а именно ConstBufferSequence или MutableBufferSequence. Boost.Asio уже содержит некоторые классы, моделирующие эти требования. Вы не обращаетесь к ним напрямую, вы используете функцию buffer(). Так можно оборачивать char[], std::string, std::vector и др.</li>
    <li><b>boost::asio::signal::set</b>. Множество зарегистрированных сигналов. Когда приходит один из таких сигналов вызывается обработчик с сигнатурой void (boost::system::error_code ec, int signo)</li>
    <li><b>boost::asio::signals_.async_wait</b> - ожидает поступление зарегистрированного сигнала и вызывает обработчик</li>
    <li><b>boost::asio::async_read_some(buffer, handler)</b>. Эта функция запускает асинхронную операцию получения данных от сокета. Для асинхронных функций обработчик имеем следующую сигнатуру void handler(const boost::system::error_code& e, size_t bytes). </li>
    <li><b>boost::asio::async_write(stream, buffer [, completion] ,handler)</b>. Эта функция асинхронно пишет в поток. По завершении вызывается обработчик. Он имеет следующую сигнатуру void handler(const boost::system::error_code & err, size_t bytes);. При необходимости вы сами можете задать completion функцию</li>
    <li><b>boost::asio::async_read_some(stream, buffer, handler)</b> - вызывает обработчик, когда на сокете имееются данные на чтение. При этом не обязательно, чтобы сообщение было доставлено целиком. Удобно, когда данные из сообщения могут обрабатываться через конечные состояния</li>
    <li><b>std::tie</b> служит для распаковки переменных из возвращаемого кортежа. Например std::tie(a, b) = std::make_tuple(2, 3);</li>
    <li><b>std::ignore</b> предназначен для использования с std::tie при распаковке std::tuple в качестве заполнителя для аргументов, которые не используются.</li>
    <li><b>std::hex</b> используется для предстваления чисел в шестнадцатеричной форме. Также позволяет преобразовывать числа из stream. std::istringstream("2A") >> std::hex >> n;</li>
</ul>
